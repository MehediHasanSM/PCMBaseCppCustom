% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/BenchmarkRvsCpp.R
\name{MiniBenchmarkRvsCpp}
\alias{MiniBenchmarkRvsCpp}
\title{Evaluate the likelihood calculation times for example trees and data}
\usage{
MiniBenchmarkRvsCpp(data = PCMBaseCpp::benchmarkData, nRepsCpp = 10L,
  listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-09,
  PCMBase.Threshold.SV = 1e-09))
}
\arguments{
\item{data}{a `data.frame` with at least the following columns: 
\itemize{
\item{tree: }{a list column of phylo objects with an edge.part member set.}
\item{X: }{a list column of k x N numerical matrices.}
\item{model: }{a list column of PCM objects.}
}
Defaults: to `benchmarkData`, which is small data.table included
with the PCMBaseCpp package.}

\item{nRepsCpp}{: number of repetitions for the cpp likelihood calculation 
calls: a bigger value increases the precision of time estimation at the 
expense of longer running time for the benchmark. Defaults to 10.}

\item{listOptions}{options to set before measuring the calculation times. 
Defaults to `list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9)`. 
`PCMBase.Lmr.mode` corresponds to the parallel traversal mode for the tree 
traversal algorithm (see 
\href{https://venelin.github.io/SPLITT/articles/SPLITTTraversalModes.html}{this page}
for possible values).}
}
\value{
a data.frame.
}
\description{
Evaluate the likelihood calculation times for example trees and data
}
\examples{
\dontrun{
library(PCMBase)
library(PCMBaseCpp)

# original MGPM model
MiniBenchmarkRvsCpp()

# original MGPM model and parallel mode
MiniBenchmarkRvsCpp(
listOptions = list(PCMBase.Lmr.mode = 21, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))

# single-trait data, original MGPM model and single mode and enabled option PCMBase.Use1DClasses
MiniBenchmarkRvsCpp(
data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(model, function(m) PCMExtractDimensions(m, dims = 1)))],
listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9,
PCMBase.Use1DClasses = FALSE))

# random BM (non-MixedGaussian) model and parallel mode
MiniBenchmarkRvsCpp(
data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X,
 model = modelBM)],
listOptions = list(PCMBase.Lmr.mode = 21, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))

# random OU (non-MixedGaussian) model and parallel mode
MiniBenchmarkRvsCpp(
data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X,, 
 model = modelOU)],
listOptions = list(PCMBase.Lmr.mode = 21, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))

# test on sinlge-trait data, BM (non-MGPM) model.
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(modelBM, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9, 
 PCMBase.Use1DClasses = FALSE))
 
 
# test on sinlge-trait data, OU (non-MGPM) model.
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(modelOU, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))
 
# test on sinlge-trait data, OU (non-MGPM) model with enabled option PCMBase.Use1DClasses = TRUE
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(model, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9,
   PCMBase.Use1DClasses = FALSE))

# test on sinlge-trait data, OU (non-MGPM) model with enabled option PCMBase.Use1DClasses = TRUE
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1:2,, drop=FALSE]), 
 model = lapply(modelOU, function(m) PCMExtractDimensions(m, dims = 1:2)))],
 listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9,
   PCMBase.Use1DClasses = TRUE))

MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(model, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))

#' # test on sinlge-trait data using the PCMBase.Use1DClasses = TRUE option
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(model, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(
   PCMBase.Lmr.mode = 11, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9,
   PCMBase.Use1DClasses = 1))

# test on sinlge-trait data in parallel mode
MiniBenchmarkRvsCpp(
 data = PCMBaseCpp::benchmarkData[, list(
 tree, 
 X = lapply(X, function(x) x[1,, drop=FALSE]), 
 model = lapply(model, function(m) PCMExtractDimensions(m, dims = 1)))],
 listOptions = list(PCMBase.Lmr.mode = 21, PCMBase.Threshold.EV = 1e-9, PCMBase.Threshold.SV = 1e-9))

MiniBenchmarkRvsCpp(listOptions = list(PCMBase.Lmr.mode = 21))
}
}
